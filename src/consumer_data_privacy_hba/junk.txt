	// since Java ints are only 32 bits, evil Bob could take Alice's declared
    //  hash-of-nonce and by brute force determine what her nonce-contribution value is going
    // to be, and thereby be able to determine his own nonce-contribution so as to force
    // the nonce to a previously-used value.   A naive brute force attack like this would
    // not work for 64-bit longs, though maybe some more sophisticated approach would.  For
    // the short term, I recommend that you just make  nonces "long" instead of "int".
	
	
	LinkedHashMap <String, String> level1Frames;	 	// Level1 Frame structure <Concatenation of Chromosome + Start + End+ locations and RSIDs, HashedValue>
													 	// Using Linked Hashmap so that the order of creating Frames is preserved.
	LinkedHashMap <String, String> match;

	level1Frames = new LinkedHashMap<String, String>();
	match = new LinkedHashMap<String, String>();
	
	level1Frames.put(String.valueOf(chromosome)+"#"+String.valueOf(start)+"#"+startRsid+"#"+String.valueOf(end)+"#"
	+endRsid, getSHAWitnNonce(substring.toString(),nonce));

/*
	 * public void putInClass(String file) {
	 * 
	 * Map <String, SNPInfo> dna= new HashMap<String, SNPInfo>(); String line ="";
	 * try { FileReader fr = new FileReader(file); Scanner sc =new Scanner(fr);
	 * while (sc.hasNextLine()) { line=sc.nextLine(); String[] row=line.split("\t");
	 * 
	 * SNPInfo snpData= new SNPInfo(row[0],row[2],row[3]); if (isHomozygous(row[3]))
	 * { dna.put(row[1],snpData); } } sc.close();
	 * System.out.println("\nNew Map: \n"+ dna);
	 * 
	 * }catch(IOException e) { System.out.println("Exception in reading at "+file);
	 * e.printStackTrace(); } }
	 */
	
	 /*public void hashMatch() {
 	
 	//System.out.println("\nHashCode Generated by SHA-256 for:"); 
    //System.out.println("\n Alice: " + alice+ getSHA(alice)); 
	    //System.out.println("\n Bob  : " + bob + getSHA(bob)); 
	    
	    if (alice.equals(bob))
	    	System.out.println("\n Alice and Bob Matches");
	    else
	    	System.out.println("\n Alice and Bob Don't Match");    	
 }



public void readFromAlice(){
	try {
			FileReader fr = new FileReader("input/alice.txt");
			Scanner sc =new Scanner(fr);
			while (sc.hasNextLine()) {
				alice=sc.nextLine();
			}
			fr.close();
			sc.close();
	}catch(IOException e) {
		System.out.println("Exception in reading from Alice");
		e.printStackTrace();
	}
	
}



public void readFromBob() {
	
	try {
		FileReader fr = new FileReader("input/bob.txt");
		Scanner sc =new Scanner(fr);
		while (sc.hasNextLine()) {
			bob=sc.nextLine();
		}
		fr.close();
		sc.close();
	}catch(IOException e) {
	System.out.println("Exception in reading from Bob");
	e.printStackTrace();
}
	
}*/
	
	//Method to display the Frame Structure
	public void displayFrames (LinkedHashMap <String, String> frames) {
		for(Map.Entry<String, String> m:frames.entrySet()){  
			   System.out.println("\nLocation Details : " +m.getKey()+" || Hashed Text :  "+m.getValue());  
			  }   
	}
		
	//Method to check if the Hashes from the frames match
	public void hashMatch(LinkedHashMap <String, String> party) {
		
		for(Map.Entry<String, String> m:level1Frames.entrySet()){
			String key1 = m.getKey();
			for(Map.Entry<String, String> p:party.entrySet()){
				String key2=p.getKey();
				if (key1.contentEquals(key2)) {
					String value1 = m.getValue();
					String value2 = p.getValue();
					if (value1.contentEquals(value2))
						match.put(key1,value1);
				}
			
		}	
		}
		displayFrames(match);
	}
	
	//Method to check if the Frame boundaries match or not between parties
	public void locMatch(LinkedHashMap <String, String> party) {
	int count=0;	
	System.out.println("\n Matches in Locations\n\n");
		for(Map.Entry<String, String> m:level1Frames.entrySet()){
			String key1 = m.getKey();
			for(Map.Entry<String, String> p:party.entrySet()){
				String key2=p.getKey();
				if (key1.contentEquals(key2)) {
					System.out.println("Location : " +key1);
					count++;
				}
		}	
		}
		
		System.out.println("\n Size of T1   Frame : " +t1);
		System.out.println("\n No. of Alice's Frames : " +level1Frames.size());
		System.out.println("\n No. of Bob's   Frames : " +party.size());
		System.out.println("\n No. of Match   Frames : " +match.size());
		System.out.println("\n No. of Frames matches b/w Alice and Bob : " +count);
		System.out.println("\n Size of locRsid : " +locRsid.size());
		System.out.println("\n Size of locGene : " +locGene.size());
	}
	
	//Junk
	public void deleteLocationFromMaps(int chromosome, int location) {
		
		for(Map.Entry<Integer, SortedMap<Integer, String>> entry : locRsid.entrySet()){ 
			if ((entry.getKey())==chromosome) { 
				SortedMap<Integer, String> temp = entry.getValue(); 
				temp.remove(location);
				System.out.println("DOne");
				} 
			}
		for(Map.Entry<Integer, SortedMap<Integer, String>> entry1 : locGene.entrySet()){ 
			if ((entry1.getKey())==chromosome) { 
				SortedMap<Integer, String> temp1 = entry1.getValue(); 
				temp1.remove(location);
				System.out.println("DONE");
				} 
			}
	}
	
	//Junk
	public void locationMatch(Map <Integer, SortedMap <Integer,String>> gene) {
		int count=0, location;
		for(Map.Entry<Integer, SortedMap<Integer, String>> entry : locGene.entrySet()) {
			int chromosome=(entry.getKey());
			SortedMap<Integer, String> temp = entry.getValue(); 
			Set<Entry<Integer, String>> sm =temp.entrySet();
			Iterator<Entry<Integer, String>> i=sm.iterator();
			while (i.hasNext()) 
	        { 
				System.out.println("\n"+count++);
				Map.Entry<Integer, String> m = (Map.Entry<Integer, String>)i.next();
				location=(Integer) m.getKey();
				if (findLocationInMaps(chromosome,location, gene)==false)
					deleteLocationFromMaps(chromosome,location);
				System.out.println(locGene);
				System.out.println(locRsid);
	        }
		}
	}
	
	
	//Junk Method to show special characters in the DataFiles
		public void showSpecial() {
			
			int c=0;
			System.out.println("Start");
			for(Map.Entry<Integer, SortedMap<Integer, String>> entry : locGene.entrySet()) {
				int chromo=entry.getKey();
				SortedMap<Integer, String> temp = entry.getValue(); // SortedMap Iterator containing location and genotype
				Set<Entry<Integer, String>> sm =temp.entrySet();
				Iterator<Entry<Integer, String>> i=sm.iterator();
				while (i.hasNext()) 
		        { 
					Map.Entry<Integer, String> m = (Map.Entry<Integer, String>)i.next();
					int key=m.getKey();
					String value=m.getValue();
					if (value.contentEquals("--")) {
						c++;
						System.out.println("\n Count : "+c+" || Chromosome : "+chromo+" || Location : "+key+" || Gene : "+value);
					}
		        }
			}
			System.out.println("END");
		}
		
		
		
		
	public void readFile(String location) {
				
		String line ="";
		try {
			FileReader fr = new FileReader(location);
			Scanner sc =new Scanner(fr);
			while (sc.hasNextLine()) {
				line=sc.nextLine();
				String[] row=line.split("\t");
				
				// Read chromosomes only between 1 and 22
				if (isParsable(row[1])){
					if ( locGene.containsKey(Integer.parseInt(row[1])) ) {
						locGene.get(Integer.parseInt(row[1])).put(Integer.parseInt(row[2]),row[3]);
						locRsid.get(Integer.parseInt(row[1])).put(Integer.parseInt(row[2]),row[0]);
					}
					else{
						SortedMap <Integer,String> sm=new TreeMap<Integer,String>();
						SortedMap <Integer,String> sm1=new TreeMap<Integer,String>();
						sm.put(Integer.parseInt(row[2]),row[3]);
						sm1.put(Integer.parseInt(row[2]),row[0]);
						locGene.put(Integer.parseInt(row[1]),sm);	
						locRsid.put(Integer.parseInt(row[1]),sm1);
					}			
				}
			}
			sc.close();
		}catch(IOException e) {
		System.out.println("Exception in reading at "+location);
		e.printStackTrace();
	}	
	}		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		